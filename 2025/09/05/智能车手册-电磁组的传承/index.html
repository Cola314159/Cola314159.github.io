<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">





<title>智能车手册——电磁组的传承（持续更新） | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Cola’s  Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Cola’s  Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">智能车手册——电磁组的传承（持续更新）</h1>
            
        </header>

        <div class="post-content">
            <h1 id="智能车-电磁组的传承（持续更新）"><a href="#智能车-电磁组的传承（持续更新）" class="headerlink" title="智能车-电磁组的传承（持续更新）"></a>智能车-电磁组的传承（持续更新）</h1><p>这里是自然选择号，我们是第二十届智能车的参赛成员，在2025年的夏天有幸参加了杭电的第二十届智能车国赛，我们基本上看了所有组别的比赛情况，看完大受震撼，许多竞赛强校如哈工大、哈工程、杭电等等，他们包揽了几乎所有组别的国一，而河南大学只能偶尔出一个国一，相信你们也在车库的墙上看到了，这说明我们比他们差吗？我觉得并非，很大一部分原因就是我们实验室从来没有一个真正的传承，这在我们备赛时深有体会，许多坑或者说许多解决方案可能我们的学长学姐已经解决过了，可我们还在重复造轮子。跌跌撞撞，让本就不充裕的备赛时间浪费在一点点小问题上，这也是我写这篇文章的原因，站在前人的肩膀上可以让我们看的更远，我们非常感谢十八届，十九届智能车的老学长的支持，没有他们的帮助，就没有现在的自然选择号。因此，我要在这里写下所有我对电磁车的理解，让你们去参考，但前人的经验并非总是对的，<strong>经验往往也意味着错误，你们要始终以批判的态度去对待新事物。</strong></p>
<p><strong>希望，可以让你们接下我们的遗憾，挺进国一</strong>。</p>
<p><strong>更希望，这份文档可以帮助你们，你们也可以接下这份传承，让车库越来越好</strong>。</p>
<p><img src="/./C:/Users/Lenovo/Desktop/MarkDown/%E6%99%BA%E8%83%BD%E8%BD%A6-%E7%94%B5%E7%A3%81%E7%BB%84%E7%9A%84%E4%BC%A0%E6%89%BF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.assets/5d9741c12cd6dc1d71f71972e3e99f2e.jpg" alt="5d9741c12cd6dc1d71f71972e3e99f2e"></p>
<p><em>这份MarkDown文档的编排顺序即我们调车的一步又一步的过程，是和自然选择号的成长过程重合的，我尽量多的把我们踩过的坑写在里面，让你们少走些弯路，你们可以按照文档里的步骤来一步一步让自己的车跑起来，这样会轻松一些，但轻松并不意味着走了正确的路，“鼓励探索，追求卓越”这是智能车大赛的追求，也是我想写在前面告诉你们的。至于我为什么把这个文档放在GitHub的个人博客里，是因为并不想让这份文档传播出去，放CSDN，知乎，都会被所有人看到。这份文档只面向车库开源，这是一代又一代老学长的心血，是车库的私有财产，也希望大家不要将本网站域名发给车库外的同学。</em></p>
<h2 id="关于电磁循迹"><a href="#关于电磁循迹" class="headerlink" title="关于电磁循迹"></a>关于电磁循迹</h2><p><strong>先简单讲一下电磁循迹的原理</strong>。</p>
<p>电磁场地是赛道中央铺设电磁线，电磁线的两头接信号发生器形成闭合回路，这时整条电磁线就通过有20kHz，100mA的正弦电流，电生磁会让漆包线周围产生周期变化的磁场，而我们的电磁车的传感器有<strong>LC并联选频</strong>的电感，<strong>只选取</strong>空间中20kHz这个频率的电磁信号，感应出感应电动势，再经过运放来放大这个信号，交给单片机的ADC去读取，就可以读到一个电压。这个电压大小会和电感与电磁线的相对位置的变化而变化，这里讲的是位置，而非距离。因为我们知道一根通电导线，它周围的磁场分布满足右手定则，电感的结构是很多匝线圈，只有通电导线产生的磁感线垂直线圈平面，它在此处的感应电动势才是最大的，当然电感距离导线越近，它读到的电压也会相应更大。</p>
<ul>
<li>简单的来说，就是<strong>电感距离磁场越近，产生的感应电动势越大，距离越远，产生的感应电动势越小。</strong></li>
<li><strong>电感的布局</strong>，即与电磁线夹的角度，影响着小车运动时切割磁感线产生的感应电动势，对循迹与元素识别起着重大影响。</li>
<li>直观的来说，将车静置在赛道中央，同一水平高度上，与电磁线方向垂直放置的电感，获取的值最大，平行的电感，获取的值最小。</li>
</ul>
<p>我在这里标了几个关键词，一个是LC并联选频，这个很重要，它选频的精度直接影响了小车读取信号的精度，对于缩微的赛道这一点更应被重视，这里强烈建议大家尽快在前期确定好自己电感排布的方案，尽快换上<strong>联物电子的黄色配频电感</strong>来调试，虽然贵，但电感就是我们电磁车的眼睛，循迹只能依靠那几个冰冷的数字，马虎不得，<strong>一定要舍得花钱，知识是无价的！</strong></p>
<h2 id="关于电感排布"><a href="#关于电感排布" class="headerlink" title="关于电感排布"></a>关于电感排布</h2><h3 id="电感的位置"><a href="#电感的位置" class="headerlink" title="电感的位置"></a>电感的位置</h3><p>电感的排布是相当讲究的，它直接影响了小车的响应特性，甚至决定了小车的速度上限，我们的赛道有直角，折线，六边形环岛，十字，折线这些元素。经过多次尝试，我们的小车最终采用了如下的电感排布，<strong>三颗横电感，两颗竖电感</strong>，在我们的代码中从左到右分别命名为 left1 left2 middle right2 right1 ，其中左一和右一两颗电感在直线以及小角度折线循迹时比较重要，因为在直道上这两颗电感读取的值最大，竖电感的值几乎为0。在面对直角以及大角度直线时，这两颗电感读到的值就不够大了，作用也会不够显著，因此在直角时，主要是竖直电感在起作用。中间那颗横电感呢？它是我们控制的核心，是我们代码里最最核心的部分。这在后文的控制部分会详细讲到。</p>
<p>下图为自然选择号的电感排布。（这时候还是破烂小三轮）</p>
<p><img src="/./C:/Users/Lenovo/Desktop/MarkDown/%E6%99%BA%E8%83%BD%E8%BD%A6-%E7%94%B5%E7%A3%81%E7%BB%84%E7%9A%84%E4%BC%A0%E6%89%BF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.assets/e497188788f7b0486a21fde52bac8994.jpg" alt="e497188788f7b0486a21fde52bac8994"></p>
<p>在前面讲到过，前人的经验并非总是对的，我们18届的老学长采用的是五颗<strong>八字电感排布</strong>，所谓八字电感，就是把那两颗竖直电感改为了向外侧倾斜45°的方式，我们一开始什么也不了解，选择直接照搬老学长的结构，但在之后的测试中效果并不理想，后来才了解到，学长当年是负压电磁，用的PVC赛道，没有尖锐的转折，是平滑的弧线构成的直角和弯道，八字电感的倾斜角度刚好可以保持和曲线垂直，且过渡较为平滑。在他们那一年，这个结构是比较好用的。后来经过一段时间的试错，我们放弃了这个结构，改成了前面的那种结构。</p>
<p>在第二十届最终的比赛中，我们留意了所有的电磁车的电感排布，很多用的是和我们一样的结构，五颗电感垂直排布，几乎没有看见用八字电感排布的，这说明我们走的弯路是对的，最后的决定也是对的，因为在国赛，好的设计都是趋同的。</p>
<p>非常值得一提的是，我们看到的另外一个结构，也是垂直结构，但只有四颗电感，没有中间那颗，和逐飞的学习版前瞻很像，不同的是它左侧两电感以及右侧两电感，一横一竖挨的十分紧，我们这一年的国冠采用的即是这种结构，这和他们的控制代码是联系十分紧密的，我和这些队伍的成员交流过，他们采用的控制算法叫<strong>差比和差</strong>，在CSDN上有十分详细的文章来解释这个算法，我在省赛前有尝试过这个办法，比<strong>普通差比和</strong>算法优越太多，但可惜留给我们尝试的时间不多了，我们为了保守一点稳定一点，还是采用了我们的老办法：<strong>基于中间横电感的动态权重</strong>。差比和差这个办法是值得尝试的，我的尝试差比和差的代码也在我留给你们的文件夹里，希望后来者可以试试。</p>
<p><strong>说完了优点，那该聊聊缺点了</strong>。</p>
<p>我们采用的这个垂直电感排布，遇到了一个很矛盾的问题，在缩微赛道，车车是很小的，前瞻也不能伸出去太多，否则会有串道的风险，这就会让小车在接近直角时，竖直电感变化的速度会非常非常快，极容易造成超调，拐弯会很猛，拐弯过猛就会导致小车速度一下就掉下来了，拐完弯就又要重新加速，十分浪费时间，而且我们还需要无线充电，电容组里存储的电能本就不多，这样会十分费电。那如果拐弯不猛呢？可不可以让弯道的PID调控力度不那么大？也不行，至少对于缩微赛道不行，因为赛道中直角与直角是不一样的，有的直角距离相邻电磁线只有30cm，调小一点就会让这种位置的直角串道。所以这也是我推荐大家尝试差比和差的原因，因为它相较动态权重，调节a,b,c的参数，拐弯会平滑一些。</p>
<h3 id="电感杆的长度"><a href="#电感杆的长度" class="headerlink" title="电感杆的长度"></a>电感杆的长度</h3><p>如果你看过曾经电磁车的视频就会发现，他们的电磁杆伸的非常靠前，而且越靠前的车越快，我刚开始也刷到过，我还觉得这玩意真丑，但这对于电磁车非常重要，因为小车的反应是有延迟的，你不可能让一个有质量且速度很大的物体在极短的时间内拐很急的弯，这需要很大的力才能使它的动量急速改变，看过三体的同学应该知道，能完成锐角转弯的只有水滴，但这是自然选择号。所以电感杆的位置越靠前，留给小车反应的时间就越长，但一般来说，一个电感杆的长度就对应一个电磁车的速度，当你的速度太小，留给小车反应的时间太长，小车就会提前拐弯，切内角过去，假如切内角不违反规则，你可以大胆去做，这样反而更快，但近两届比赛都有锥桶，小心别撞上了。当你的速度太大，小车的杆伸的不长，就会让小车反应不过来，就会冲出去。</p>
<p>你们在调车的时候，可以从低速慢慢调，调差不多了开始上速度，就可以确定一个比较合适的长度了。</p>
<p>我们的杆长度也就十五厘米？具体没量过，估摸着试试吧，我们设太长了会发现撞锥桶，以及会串道，因为我们的赛道极其紧凑，杆子太长拐弯时就会扫到相邻的线。</p>
<h3 id="电感的高度"><a href="#电感的高度" class="headerlink" title="电感的高度"></a>电感的高度</h3><p>电感的探测范围和高度有关。你可以把电感想象成一颗向下照的灯泡，一颗灯泡向下照，他照射的范围和高度有关，高度越高，能照亮的地面面积越大，贴在地上，就只能照亮极小的范围了，所以小车可以探测的范围和小车的前瞻高度是紧密相连的，想让小车看的更远，你除了把电感杆的长度延长外，还可以把前瞻抬高。</p>
<p>以下是我们小车前瞻的高度</p>
<p><img src="/./C:/Users/Lenovo/Desktop/MarkDown/%E6%99%BA%E8%83%BD%E8%BD%A6-%E7%94%B5%E7%A3%81%E7%BB%84%E7%9A%84%E4%BC%A0%E6%89%BF%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.assets/5cf3f6ec46a89c6d7e76c8f4ff04b14e.jpg" alt="5cf3f6ec46a89c6d7e76c8f4ff04b14e"></p>
<p>我们的前瞻离地8.5cm，为什么这么精确，因为这个我真量过，我们看了逐飞和龙邱两家的锥桶，它的高度都是8cm，8.5cm刚好可以绕过去，不那么容易撞锥桶。这个电感高度越高，小车看到的范围就越大，在一定程度上可以弥补电感杆不能伸太长的短板，而且相较于紧贴地面，当小车走到拐弯处时他电感值的变化也会比较平缓，贴太靠下就会变化非常快，平缓变化就会让小车先稍微拐一点点，而后越来越大，等直角相当近的时候基本拐的角度也足够了，视觉效果就十分丝滑，也不太掉速度，会很快，因为踩油门谁不会啊，弯道快才是真的快。</p>
<p>但是，物极必反。探测范围大了，也就意味着你很可能会探测到相邻的线，如果你的赛道没那么紧凑，这样设计没问题，但我们的赛道极其紧凑，杆子伸太长就会串道。这个你们调车的时候也需要注意一下。</p>
<h2 id="关于PID"><a href="#关于PID" class="headerlink" title="关于PID"></a>关于PID</h2><p>PID即比例积分微分控制，简称PID控制，其中P表示比例、I表示积分、D表示微分。PID控制算法是最早发展起来的控制策略之一，由于其算法简单、鲁棒性好和可靠性高，被广泛应用于工业过程控制。而且也衍生出多种相关的控制算法：P控制、PI控制、PD控制、增量式PID控制、抗饱和PID、微分先行PID、自适应PID、模糊PID控制等。虽然这些算法各不相同，但都是基于最基本的PID控制算法为原型的。</p>
<p>PID是一个极其优雅简洁又好用的控制算法，将控制的美体现的淋漓尽致。如果要详细介绍，将占用极大的篇幅，我打字也不是很快，而且自己的理解也不够深，故而不在此赘述，bilibili上有一期很好的视频，江协科技的PID教程，在我大二的那个寒假，我看了几集，大受震撼，一直受用。在调试PID之前，你一定要去看看。需重点关注位置式PID与增量式PID的区别，积分限幅，串级PID这些内容。</p>
<p>关于PID的详细知识大家可以移步江协科技PID教程，你想知道的，里面都有答案，在这里，我只讲我们的代码里用到的部分：</p>
<h3 id="增量式PID"><a href="#增量式PID" class="headerlink" title="增量式PID"></a>增量式PID</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Pid_IncCtrl</span><span class="params">(<span class="type">pid_param_t</span> * pid, <span class="type">float</span> error)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	pid-&gt;out=Constrain_float(pid-&gt;out,-5000,5000);		//限幅</span></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out &gt; <span class="number">5000</span>) pid-&gt;out = <span class="number">5000</span>;   <span class="comment">//限制最大值</span></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out&lt; <span class="number">-5000</span>) pid-&gt;out = <span class="number">-5000</span>;   <span class="comment">//限制最小值</span></span><br><span class="line">	<span class="keyword">if</span>(error&lt;<span class="number">5</span>&amp;&amp;error&gt;<span class="number">-5</span>) error=<span class="number">0</span>;</span><br><span class="line">	pid-&gt;out_p = pid-&gt;kp * (error - pid-&gt;last_error);	<span class="comment">//此次误差与上次误差之差</span></span><br><span class="line">	pid-&gt;out_i = pid-&gt;ki * error;<span class="comment">//误差</span></span><br><span class="line">	pid-&gt;out_d = pid-&gt;kd * ((error - pid-&gt;last_error) - pid-&gt;last_derivative);<span class="comment">//两次误差之差的差</span></span><br><span class="line"></span><br><span class="line">	pid-&gt;last_derivative = error - pid-&gt;last_error;  </span><br><span class="line">	pid-&gt;last_error = error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out_i&gt;<span class="number">500</span>) pid-&gt;out_i=<span class="number">500</span>;<span class="comment">//误差的限幅</span></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out_i&lt;<span class="number">-500</span>) pid-&gt;out_i=<span class="number">-500</span>;</span><br><span class="line">	</span><br><span class="line">	pid-&gt;out+=(pid-&gt;out_p + pid-&gt;out_i + pid-&gt;out_d);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out &gt; <span class="number">5000</span>) pid-&gt;out =<span class="number">5000</span>;</span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out&lt; <span class="number">-5000</span>) pid-&gt;out = <span class="number">-5000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pid-&gt;out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在pid.c这个文件里，写了两种PID，分别是位置式PID和增量式PID，这两种很好区别，我是这么理解的，所谓增量式，实际上就是一直需要误差积分，即误差累加，增量是误差的增量，所以很需要 i 项，因此在这个PID里面，i 项是最重要的，那也很容易理解，它需要累积误差才可以起作用，累计的过程必然是需要时间的，所以它一般只用于稳态误差比较大，又对响应速度要求不太高的地方，相信你也想到了，就是电机控制，对于电机的控制用增量式PID是最适合的。</p>
<p>依然是该说缺点了，我们以电机匀速转动为例，在前面提到，增量式PID很依赖误差的增量，那如果误差的增速比较快，且一直累计，那就会导致误差会累计到一个非常非常大的值，大到即使我们的电机达到目标转速也不足以短时间内消除这个误差，就会让电机先猛转一小会，直到消除了累计的误差才开始正常调控，等到小车转弯或者遇到一些别的什么情况，速度降下去了，误差又累计上去了，小车又会猛的加速，猛地加速在小车运动时的体现就是翘头，非常不丝滑，所以为了消除这个情况，我们需要进行误差限幅，当误差大到某一个值，误差就恒等于最大值就可以了。在我们的代码里就是 out_i 这一项的限幅。</p>
<p>但是仅仅对误差限幅还不够，为了保护电机，我们最好将电机转速限制在60%以下，小车跑快也用不到那么高转速，我们限制了pid最大输出5000，即限制50%占空比。</p>
<p>在使用中还有一个问题，由于没有经验，前期一直在研究循迹算法，没有顾及到PID的基础知识，时间也不足以让我把每个环节都吃透，小车跑起来看着简单，实际上里面蕴含的奥秘博大精深，一直往前看固然是好的，走的会很快，但快有什么用？把细节注意好，每一步走得稳才能走得对，走得对才更有希望胜利。我在后期注意到，我们的小车仿佛速度卡在了1.55m&#x2F;s，在此刻距离省赛不到10天，哔哩哔哩上面的大佬人均两米，最绝望的时候莫过于此，日夜不休的调车，各种办法试了个遍，仍是没有丝毫进展。而后发现小车的轮子的最大速度好像响应很差，响应不够好，在低速时候不明显，在高速时候就很差，在拐弯时外侧轮子明显响应不过来。这才了解到，是pid的最大限幅限制的太低了，而且最基础的速度环响应也不好，一直在提到的，增量式pid很依赖误差的累计，那怎样才能让响应快？必然需要误差的累计足够快！即 i 项要足够大！，速度环的增量式pid只用到pi控制即可，d项作用不大。这么说来，其实这个<strong>增量式pid的i更像是p，p又更像是d了</strong>。为什么这么说，在速度环闭环里会细说。</p>
<h3 id="位置式PID"><a href="#位置式PID" class="headerlink" title="位置式PID"></a>位置式PID</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">PidLocCtrl</span><span class="params">(<span class="type">pid_param_t</span> * pid, <span class="type">float</span> error)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 累积误差 */</span></span><br><span class="line">	pid-&gt;integrator += error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 误差限幅 */</span></span><br><span class="line">	<span class="comment">//constrain_float(pid-&gt;integrator, -pid-&gt;imax, pid-&gt;imax);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pid-&gt;out_p = pid-&gt;kp * error;</span><br><span class="line">	pid-&gt;out_i = pid-&gt;ki * pid-&gt;integrator;</span><br><span class="line">	pid-&gt;out_d = pid-&gt;kd * (error - pid-&gt;last_error);</span><br><span class="line"></span><br><span class="line">	pid-&gt;last_error = error;</span><br><span class="line"></span><br><span class="line">	pid-&gt;out = pid-&gt;out_p + pid-&gt;out_i + pid-&gt;out_d;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pid-&gt;out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位置式PID就简单的多，没有限幅，长度比增量式短太多，用法也比较简单，它不依靠i项的累加，它的响应是很快的，所以它用在传感器的pid控制里，小车在高速行驶时，对信号的突然改变如突然检测到弯道要拐弯了，是需要响应很快的，所以我们在循迹时对传感器采集到的信号进行处理时用这个PID，这个pid我们一般用pd控制，不加入i项，调试时没有太多需要注意的，在目标速度上行驶响应不够猛就加p，p加的差不多了可以响应的好了再慢慢加d，让小车不那么抖，加了d后响应还不够就接着加p，这样调就可以。</p>
<h2 id="PID定速控制——速度环闭环"><a href="#PID定速控制——速度环闭环" class="headerlink" title="PID定速控制——速度环闭环"></a>PID定速控制——速度环闭环</h2><p>每个组别装好车模的第一件事，必定是让电动机转起来，让电机转起来很简单，在逐飞例程里只需要一直给电动机输出不同占空比PWM信号即可，逐飞的PWM信号一般是占空比0–10000可调的PWM波，这样5000的duty就对应50%的占空比，在让小车动起来时，我们只需要给左右两电机固定PWM即可，不宜太大，30%的占空比已经可以让小车跑的飞快了。</p>
<p>但是，小车左右两个电机虽然给了相同的占空比，在实际下地跑的时候，小车左右轮并不会转的一样快，体现就是小车走不直。这是因为由于装配问题导致了左右轮转起来的摩擦力不同，所以在组装车模时，一定要用手转转轮子，以维持左右轮转动的阻尼感大体相同。<strong>这一点很重要！！！</strong>，左右轮调好后，小车走的可以稍微直一点点，可硬件上调整总会不太平衡的，这就需要我们控制里面最优美的算法——PID来进行调控了。</p>
<p>当然了，我们想知道小车是否达到了目标转速，肯定是需要一个可以测量速度的传感器的。这个传感器就是编码器。我们可以把编码器的代码直接拿去用，它没什么需要注意的。我们在进行速度环闭环之前，是一定要通过编码器测出来实际转速的。</p>
<p>在PID闭环调控之前，建议把按键函数写写，用按键进行调参，会方便很多。也<strong>需要下载一款上位机软件</strong>，用于观察pid响应的波形，传统派用的是vofa+，逐飞在去年也出了一款自己的上位机软件，叫逐飞助手，这两款软件网上都有安装包。大家可以根据自己喜好下载，我们调参时没考虑太多，直接用了vofa+。</p>
<p>这就到了对PID的实操环节了，下面是增量式pid，是定速控制的速度环需要的pid。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Pid_IncCtrl</span><span class="params">(<span class="type">pid_param_t</span> * pid, <span class="type">float</span> error)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	pid-&gt;out=Constrain_float(pid-&gt;out,-5000,5000);		//限幅</span></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out &gt; <span class="number">5000</span>) pid-&gt;out = <span class="number">5000</span>;   <span class="comment">//限制最大值</span></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out&lt; <span class="number">-5000</span>) pid-&gt;out = <span class="number">-5000</span>;   <span class="comment">//限制最小值</span></span><br><span class="line">	<span class="keyword">if</span>(error&lt;<span class="number">5</span>&amp;&amp;error&gt;<span class="number">-5</span>) error=<span class="number">0</span>;</span><br><span class="line">	pid-&gt;out_p = pid-&gt;kp * (error - pid-&gt;last_error);	<span class="comment">//此次误差与上次误差之差</span></span><br><span class="line">	pid-&gt;out_i = pid-&gt;ki * error;<span class="comment">//误差</span></span><br><span class="line">	pid-&gt;out_d = pid-&gt;kd * ((error - pid-&gt;last_error) - pid-&gt;last_derivative);<span class="comment">//两次误差之差的差</span></span><br><span class="line"></span><br><span class="line">	pid-&gt;last_derivative = error - pid-&gt;last_error;  </span><br><span class="line">	pid-&gt;last_error = error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out_i&gt;<span class="number">500</span>) pid-&gt;out_i=<span class="number">500</span>;</span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out_i&lt;<span class="number">-500</span>) pid-&gt;out_i=<span class="number">-500</span>;</span><br><span class="line">	</span><br><span class="line">	pid-&gt;out+=(pid-&gt;out_p + pid-&gt;out_i + pid-&gt;out_d);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out &gt; <span class="number">5000</span>) pid-&gt;out =<span class="number">5000</span>;</span><br><span class="line">	<span class="keyword">if</span>(pid-&gt;out&lt; <span class="number">-5000</span>) pid-&gt;out = <span class="number">-5000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pid-&gt;out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在让电动机匀速转动的pid里一般用pi控制器，不加入d项，前面也说了i项决定了响应速度，所以我们调这个pid时需要把p项给0，慢慢加i，等小车响应力度上来后，这时候一般是非常抖的，再慢慢加p，可以消除这个抖动。</p>
<p>连续几年国奖的智能车大佬<em>我依青山在</em>有一个办法，他是讲可以先给p和i都置0，目标速度也给0，把小车放在室内组别的坡道上，这时候小车肯定是会滑下来的，慢慢加i，直到小车可以稳稳停在坡道，抖动先不要管，响应力度上去后可以加p，消除抖动。</p>
<p>然而我们的小车比较小，比较轻，用这个调的并不准，所以可以在用青山的办法后，在此基础上用**vofa+**这一款上位机软件，直接观察波形，给一个不太大的目标速度，让小车轮子转起来，基于波形再细细调。一般目标转速的误差浮动不超过5%就可以。之后按动按键把速度提上去，再观察波形，以及响应，再细细调一遍。这时的pid参数就是比较好的参数了。</p>
<h2 id="关于ADC处理"><a href="#关于ADC处理" class="headerlink" title="关于ADC处理"></a>关于ADC处理</h2><p>电磁车的眼睛就是那几颗电感，而读取电磁信号的强弱就是要读取这几颗电感的感应电压大小，就需要用到我们单片机的ADC功能，在逐飞给的库函数里，有读取电感电压的例程，我们来一步一步分析。</p>
<h3 id="ADC采集与滤波"><a href="#ADC采集与滤波" class="headerlink" title="ADC采集与滤波"></a>ADC采集与滤波</h3><p>首先，既然我们想让小车跑的快跑得准，那它的前提就是我们读到的信号要足够精确，在实际应用中，电感会受很多因素的影响，比如电机的转动，电机转动其实也是会发出电磁波的，因为直流电机的换向器的存在，实际上电机里的线圈通过的电流方向时刻在改变，这就会产生电磁波。所以我们电机的PWM信号给的频率是17k，可以稍微减弱对电感的影响，但这也是不够的。因此我们需要用一个比较简单的办法来滤波，就是求平均数，逐飞也是用的这个办法，叫均值滤波。</p>
<p>还有就是中位值平均滤波法，它结合了中值滤波与算术平均滤波的优点，其基本原理是对连续采集的 N 个样本点去除最大值和最小值后，再求剩余 N-2 个数值的算术平均值。这种方法能够在一定程度上抑制异常值对最终结果的影响，同时保持良好的平滑效果。</p>
<p>我们为了再精确一些，就采用了去除极值的均值滤波，每次采集完十次，去除最大值和最小值，再来求平均数，而后再使用这些数据.</p>
<p>所以在这里，我们是修改了逐飞库的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint16 <span class="title function_">ADC_Read_Average1</span><span class="params">(ADCN_enum adcn,uint8 times)</span><span class="comment">//均值中值滤波</span></span><br><span class="line">&#123;</span><br><span class="line">  uint32 sum=<span class="number">0</span>;</span><br><span class="line">  uint8 t;</span><br><span class="line">	uint32 max=<span class="number">0</span>;</span><br><span class="line">	uint32 num=<span class="number">0</span>;</span><br><span class="line">	uint32 min=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//uint32 tmp=0;</span></span><br><span class="line">	uint16 delay=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	num=adc_once(adcn,ADC_12BIT);</span><br><span class="line">	max=num;</span><br><span class="line">	min=num;</span><br><span class="line">	sum+=num;</span><br><span class="line">	<span class="keyword">for</span>(;delay&lt;<span class="number">100</span>;delay++) ;</span><br><span class="line">	delay=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(t=<span class="number">1</span>;t&lt;times;t++)</span><br><span class="line">  &#123;</span><br><span class="line">		num=adc_once(adcn,ADC_12BIT);</span><br><span class="line">		<span class="keyword">if</span>(num&gt;max)			max=num;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;min)			min=num;</span><br><span class="line">		sum+=num;</span><br><span class="line">		<span class="keyword">for</span>(;delay&lt;<span class="number">100</span>;delay++) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (sum-max-min)/(times<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，adc处理后的数据就可以进行使用了.</p>
<h3 id="ADC归一化"><a href="#ADC归一化" class="headerlink" title="ADC归一化"></a>ADC归一化</h3><p>我们采集完ADC信号后会发现，这一串数字是比较大的，放赛道上大概有3000那么大，而且也会发现，换一个赛道后，由于不同的信号线通过的电流不同，那采集到的信号强度就不同，所以在不同的赛道我们读到的值就不一样，把这个值放入PID里，在不同的信号强度下就会有不同的调控力度。这就会导致我们可能换一个赛道就跑不了了，这样,我们的小车就没有良好的适应性，所以，我们需要一个统一的标准。</p>
<p>这个标准就叫归一化。通过归一化，可以将这些数据映射到一个统一的范围（如 1 ~ 100），从而简化后续的数据处理过程，并提高数据的一致性和稳定性。</p>
<p>我们可以采集一遍信号值，知道它的最大值和最小值，让这个它的最大值减去最小值，再让此刻的电感值除以这个差，就会得到一个大于零小于一的结果，再将这个值放大一百倍，那我们采集到的值就会介于0-100之间，这样，那个标准就建立了，我们以后采集到的电感信号就会有很好的赛道适应性了。</p>
<p>下面就是我们的归一化代码：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left1  = (Lnow_ADC[<span class="number">0</span>] - ad_min[<span class="number">0</span>])  * <span class="number">100</span> / (ad_max[<span class="number">0</span>] - ad_min[<span class="number">0</span>]);     <span class="comment">// 各偏移量归一化到0--100以内</span></span><br><span class="line">left2  = (Lnow_ADC[<span class="number">1</span>] - ad_min[<span class="number">1</span>])  * <span class="number">100</span> / (ad_max[<span class="number">1</span>] - ad_min[<span class="number">1</span>]);     <span class="comment">// 各偏移量归一化到0--100以内</span></span><br><span class="line">middle = (Lnow_ADC[<span class="number">2</span>] - ad_min[<span class="number">2</span>])  * <span class="number">100</span> / (ad_max[<span class="number">2</span>] - ad_min[<span class="number">2</span>]);     <span class="comment">// 各偏移量归一化到0--100以内</span></span><br><span class="line">right2 = (Lnow_ADC[<span class="number">3</span>] - ad_min[<span class="number">3</span>])  * <span class="number">100</span> / (ad_max[<span class="number">3</span>] - ad_min[<span class="number">3</span>]);     <span class="comment">// 各偏移量归一化到0--100以内</span></span><br><span class="line">right1 = (Lnow_ADC[<span class="number">4</span>] - ad_min[<span class="number">4</span>])  * <span class="number">100</span> / (ad_max[<span class="number">4</span>] - ad_min[<span class="number">4</span>]);     <span class="comment">// 各偏移量归一化到0--100以内</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="电磁运放的使用"><a href="#电磁运放的使用" class="headerlink" title="电磁运放的使用"></a>电磁运放的使用</h3><p>我们电感采集到的电压信号是极小的，所以我们需要一个放大电路来对这些信号进行放大，运放就是来做这个工作的。</p>
<p>我们的运放使用需要注意的一个点就是那几个电位器，就是那个蓝色的长方体。一个电位器对应一路运放，它的作用是调节放大倍数。</p>
<p>我们在前面的代码里展示了如何进行电感信号采集、滤波以及归一化。他们的前提都是有运放放大后的信号输入，所以，在这里要讲一下归一化之前运放的使用。</p>
<ul>
<li><p>首先，我们要对每个电感的幅值进行独立测量。首先将该电感对应的运放调节至其最小输出状态，使该电感与电磁线呈平行关系（高度不进行人为调整，保持车模自然放置高度），记录此时的读数作为最小值；然后将运放调节至最大输出状态，移动车模位置，使该电感与电磁线之间呈垂直关系（高度不进行人为调整，保持车模自然放置高度），记录此状态下的读数作为最大值。</p>
</li>
<li><p>然后，利用所测得的最大值和最小值，根据预设的归一化公式进行数据转换。</p>
</li>
<li><p>完成上述归一化过程后，使该电感与电磁线呈垂直关系，进一步微调运放，使其输出达到其最大值的 70%。其实也就是等于归一化后的70。这一数值作为车模正常运行条件下的参考值。它的作用比较显著。</p>
</li>
</ul>
<p>该过程建议选择一个相对开阔且具有较长直线段的区域，以尽量减少周围潜在的其他电磁源对电感值的干扰。</p>
<h2 id="关于基础循迹"><a href="#关于基础循迹" class="headerlink" title="关于基础循迹"></a>关于基础循迹</h2><h3 id="循迹的原理"><a href="#循迹的原理" class="headerlink" title="循迹的原理"></a>循迹的原理</h3><p>小车的循迹原理，想必已不必多说，在仔细介绍本篇之前，我们要先明白这些电感的作用，我把它分成了三类:</p>
<ul>
<li>横电感，横电感用于在直道中检测偏离直道的程度，如果小车右偏，则左横电感读到的值大，左偏同理</li>
<li>竖电感，竖电感用于检测赛道的大角度偏折，如果赛道有直角或者大角度折线，两颗竖电感的反应会很明显</li>
<li>中间横电感，它比较特殊，因为它是居中的，所以我们不用它循迹，用它来进行元素判断。</li>
</ul>
<p>而且在之前的ADC处理，我们也已经可以准确采集信号值了。</p>
<p>那么，我们就要开始使用了。</p>
<p>我们由浅入深慢慢想，假如我们的小车放在赛道的直道上，它的五颗电感都读到了值，假如小车往右行驶偏了，那么它左侧的横电感读到的数就会偏大，右边的横电感读到的数就会偏小，那通过这一现象，我们就会知道小车偏了。再进一步，我们拿左侧值减去右侧值，假如在直道，它应该是0。现在是右偏，那他是正数。左偏了，那它自然是负数。</p>
<p>通过这一运算，我们就已经发现了，假如做差的话，我们就可以很清晰的知道小车的姿态，还会知道它偏离赛道的程度是否严重。</p>
<p>基于这一办法，一种让电磁小车循迹的算法就诞生了——差比和。</p>
<p>差比和算法是一种常用的偏差计算方法，其标准形式为 (L - R) &#x2F; (L + R)，其中 L 和 R 分别表示左横电感和右横电感的读数。这种方法在处理普通赛道或轻微折线赛道时表现良好，能够提供相对准确的赛道位置偏差信息。基于这个公式，我们可以学习着进行基础循迹。</p>
<p>以下即是我们的差比和代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">	函数名		void Dif_sum()  </span></span><br><span class="line"><span class="comment">	功  能		求两种差比和，普通差比和 和 值开根后的差比和</span></span><br><span class="line"><span class="comment">*********************************************************************/</span>   </span><br><span class="line"><span class="type">void</span> <span class="title function_">Different_sum</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	sum1=(<span class="number">100</span>*(left1-right1))/(left1+right1);</span><br><span class="line">	sum2=(<span class="number">100</span>*(left2-right2))/(left2+right2);</span><br><span class="line">	</span><br><span class="line">	weight_err=sum1*<span class="number">0.8</span>+sum2*<span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是比较基础的代码，是我们比较早期的代码，在我们提供给你们的3月份还有4月份的代码里可以找到</span></span><br></pre></td></tr></table></figure>

<p>因为我们的电感实际上是两对零一个，对于这两对，我们分别进行处理，横电感是sum1，竖电感是sum2.</p>
<p>下面weight_err是在对横电感和竖电感分配一个权重，体现的是我们更信任哪一对电感。通过这一个函数，就足以让我们开始循迹了。</p>
<h3 id="循迹的实现——转向环闭环"><a href="#循迹的实现——转向环闭环" class="headerlink" title="循迹的实现——转向环闭环"></a>循迹的实现——转向环闭环</h3><p>在实现这个之前，我们先再来回顾一下PID。</p>
<p>PID算法简而言之就是输入一个误差，然后PID会有一个输出，利用这个输出来动态调节误差，使误差变为零。</p>
<p>那么在小车姿态和位置控制里，这个误差显然就是小车偏离赛道中线的程度，其实也就是上面那个函数weight_err算出来的值，而我们的目的就是为了把这个weight_err消除。因此，我们需要输入给PID控制器的就是weight_err。</p>
<p>接下来，我们该选取合适的PID控制器了，有两种，一种是增量式，一种是位置式。</p>
<p>在前面我们已经讲了它们的特点，增量式需要误差累计，它的响应没有位置式快。而位置式的响应是很快的，不依赖误差累计。所以很显然，我们需要选择位置式PID。小车的姿态控制是需要响应足够快的。而且也没什么稳态误差需要消除。</p>
<p>所以，我们可以将误差输入给位置式PID，调节位置式PID的参数，来计算出一个合适的值，计算出的这个值作用于小车这个系统，小车的转向就可以实现了。我们把这一环PID叫做转向环。既然我们需要这个转向环作用于小车来调整位置，那这个PID的输出就应该作用于电动机。我们选择了让这个转向环PID计算出的值对应一个目标差速，让左右轮的基础目标转速与这个目标差速相加或者相减，这样得到一个带差速的目标转速，再将这个带差速的目标转速作用于速度环，控制小车左右轮分别趋近小车左右轮的处理后的目标转速。简单来说就是控制左轮速度比右轮大就右转，反之左转。这样就可以进行循迹了，其实也就是相当于这个转向环串在了速度环上。这也是一种简单的串级PID。</p>
<p>我们的转向环控制代码，它放在了中断服务函数里执行。这个中断函数每5ms执行一次。它是不必要放在主函数循环里的，这样会让小车来不及调整状态就又有新的指令来了，也会造成大量处理器资源浪费。讲到这里当然又要讲一下中断了，我们可以把小车的控制函数一类放在较短周期的中断里执行，把按键读取，电压检测等函数放在另一个20ms周期的函数里执行。以节约单片机的资源，达到高效控制。</p>
<p>以下即是我们的控制代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TM1_Isr</span><span class="params">()</span> interrupt 3      <span class="comment">/*只放电感,元素和速度控制,其他放定时器4*/</span>  <span class="comment">//定时器0和1硬件自动清零</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">/*电感***************/</span></span><br><span class="line">		Transit_inudctor();</span><br><span class="line">		InductorNormal();</span><br><span class="line">		Different_sum();</span><br><span class="line">		<span class="comment">/******读取编码器************/</span></span><br><span class="line">		ECPULSE_L=-Read_Encoder(<span class="number">1</span>); </span><br><span class="line">		ECPULSE_R=Read_Encoder(<span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">		err=weight_err;</span><br><span class="line">		target_Dif=(int16)PidLocCtrl(&amp;DifSpeed_PID,err);</span><br><span class="line">		targetL=target-target_Dif;</span><br><span class="line">		targetR=target+target_Dif;</span><br><span class="line">		SpeedCtrl(targetL,targetR);	</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是比较基础的代码，是我们比较早期的代码，在我们提供给你们的3月份还有4月份的代码里可以找到</span></span><br></pre></td></tr></table></figure>

<p>好了，下一步就是调PID了，这个PID是位置式的，而且它并不需要消除稳态误差，所以也就是我们不需要i项。</p>
<p>这里P项大了会提高响应速度和响应力度，D项大了可以抑制小车超调，这里没什么太多要注意的，只需要先把这俩都置零，把目标基础速度，也就是target也置0，再把小车放赛道上，慢慢加P，转动小车，看小车回复力度如何，慢慢加，感觉可以了可以加D来削弱震荡。等小车响应速度比较合适了之后就可以增加target这个目标速度了，让小车跑起来，通过现象来判断如何调整。如果有的弯拐不过去，加P就好了。</p>
<p>做到这里，就恭喜你们，你们的小车，已经可以开始循迹了！</p>
<h2 id="关于你们可能会遇到的元素"><a href="#关于你们可能会遇到的元素" class="headerlink" title="关于你们可能会遇到的元素"></a>关于你们可能会遇到的元素</h2><p>我们这一年遇到的元素有直角，折线，十字路口，六边形环岛。（听说会有立体赛道？或者会飞的电磁车？解决办法留给你们了！）</p>
<p>基本上智能车也就只会有这些元素了。</p>
<p>下面，我来讲讲这几个元素分别有怎样的特点。</p>
<h3 id="直角（大角度折线）"><a href="#直角（大角度折线）" class="headerlink" title="直角（大角度折线）"></a>直角（大角度折线）</h3><p>直角它的难点其实在于一个很大角度的转折，它要求小车可以以很好的姿态拐过去，假如拐的力度不够，它有可能冲出赛道，也有可能串道。假如拐的力度太大，虽然拐过去了，但拐太猛了，小车速度掉的很快，这会浪费大量时间，限制小车整体速度的点就在这里。</p>
<p>它的特点是小车在行驶到接近直角的地方时，最中间的那颗横电感感应到的值会骤减，而且小车位置的误差值会变的很大。这表明直道在前面已经不再直了，其实遇到大角度的折线也是这种情况，所以我们不必区分这两者，也不必区分左直角还是右直角，因为它们都是要让小车快速且准确的响应嘛。</p>
<p>其实处理这个情况我们的基础循迹就已经有一点点力不从心了，它没法控制的很精确，我们能做的只有分段调节PID，即识别到中间电感读数过小，并且误差值较大，就可以换一套转向环PID参数（换大一点的），这就是分段式PID。利用这个办法，可以凑合着解决这个问题。</p>
<p>以下是我们判断大角度折线（直角）的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Big_turn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(err&lt;<span class="number">0</span>) Er=-err;</span><br><span class="line">	<span class="keyword">else</span> Er=err;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Er&gt;<span class="number">50</span> &amp;&amp; middle&lt;<span class="number">60</span> &amp;&amp; round_flag==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		turn_flag=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Er&lt;<span class="number">50</span> &amp;&amp; turn_flag==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		turn_flag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是这里的标志位需要区分开，各标志位相互独立。因为在环内，环内的折线也满足以上条件，所以我们还要判断一下小车现在是否在环内。</p>
<h3 id="十字路口"><a href="#十字路口" class="headerlink" title="十字路口"></a>十字路口</h3><p>十字即两条相互垂直的直线，它这里容易出现的问题是：假如小车进入十字路口的姿态不够正，就会出现一侧电感读到的数偏大，另一侧又偏小，这极有可能导致我们的小车不直走，而是直接在路口转弯。所以我们有两种办法解决这个问题:一种办法是结合十字路口的特点，检测到路口就先直走一小段路程，然后再关闭这个状态。另一种办法是我们把小车姿态控制好一点，直接从根源上解决这个问题。其实，后者是最好的办法，因为它比较简洁，小车的判断越多，代码越复杂，出现问题的概率就越大。好的代码往往都是简洁且高效的。</p>
<p>十字路口的特征是这样的：小车中间那颗电感读数以及两侧横电感读数都是直道上的正常值，左右竖电感读数读数都偏大，且大小差不多。误差也没那么大。</p>
<p>因为我们的控制比较精细，小车从来没有在十字路口出现过问题，所以我们不做处理，这里也建议你们尽量控制好小车姿态，尽量别去单独处理十字。</p>
<h3 id="六边形环岛"><a href="#六边形环岛" class="headerlink" title="六边形环岛"></a>六边形环岛</h3><p>这是小车控制里面最难的一个点了，我在这里需要很仔细的来讲。</p>
<h2 id="关于核心控制算法"><a href="#关于核心控制算法" class="headerlink" title="关于核心控制算法"></a>关于核心控制算法</h2><h2 id="提速——关于串级PID"><a href="#提速——关于串级PID" class="headerlink" title="提速——关于串级PID"></a>提速——关于串级PID</h2>
        </div>

        
            <section class="post-copyright">
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>欢迎你来翻阅</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>世之奇伟，瑰怪，非常之观，常在于险远，非有志者不能至也。</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/09/06/%E7%AB%8B%E5%88%9B%E5%AE%9E%E6%88%98%E6%B4%BEESP32S3%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/">立创实战派ESP32S3学习历程</a>
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>